# 原型和原型链
## 原型的概念：
每个js对象创建时对会与另一个对象相关联，被关联的这个对象就叫原型，被创建的对象会从原型中继承属性
  1. prototype：
      * 每个函数都有这个属性，这个属性指向函数的原型对象；xxx.prototype就叫做原型对象
			* 使用这个函数创造其他的对象时，对象也继承了原型对象上的属性
  2. _proto_：每个对象都有这个属性，指向该对象的原型（p._proto_===P.prototype）
  3. constructor：
    * 每个原型都有一个constructor属性（也就是说，在prototype上），指向关联的构造函数
  	* 即：P.prototype.constructor===P===p.constructor;
  4. 原型的原型：原型本质也是对象，也就是原型的_proto_指向原型的原型：Object.prototype

##  原型链：
* 每一个函数都有一个原型对象；
* 原型对象都包含一个指向构造函数的指针；
* 每一个实例都包含一个指向原型对象的内部指针
* 如果原型对象是另一个类型的实例；那么：
* 这个原型对象将包含一个指向另一个原型的指针；而这个原型又包含着指向另一个构造函数的指针……
* 层层递进，就构成了原型和实例的链条：原型链
## 确定原型关系的方法：
  * instanceof：实例和原型链中出现过的构造函数，返回true；
  * isPrototypeOf：是否是参数的原型：P.prototype.isPrototypeOf(p)
  * Object.getPrototypeOf(obj)返回对象的原型对象

## prototype和_proto_的关系和区别：
* 实例的_proto_指向原型对象（xxx.prototype）
* 构造函数的prototype指向原型对象
* 原型对象的constructor指向相关联的构造函数

### 原型对象的好处是所有实例对象共享它的属性和方法
* 当实例和原型有同名属性时，会屏蔽掉原型的属性(理解为就近原则)；

### 一些方法：
* 判断属性是在实例中还是在原型中，使用hasOwnProperty方法，在实例中时返回true
* in操作符会遍历所有属性，无论是在实例上还是原型上
* Object.keys(obj)获取对象所有可枚举属性的名称

### 如果在实例属性上没有找到想要的属性，会沿着原型链向上找；直到Object,所有的对象最终都会指向Object

# [JS继承的方式及比较](../手撕代码/几种继承方式.js)
* 每一个对象都有一个_proto_属性（隐式原型），每一个构造函数都有一个prototype（显式原型）
* 实例的隐式原型==构造函数的显式原型
1. 原型链继承
	* 让子类的prototype(原型对象)等于父类的实例：sun.prototype=new dad();
   * 特点：
     1. 由子类构造的实例，既是子类的也是父类的
     2. 父类新增原型方法和属性子类都能访问到
	* 缺点：来自原型对象的引用属性是所有实例共享的，没有私有化
2. 构造函数继承
   * 在构造子类构造函数内部使用call或apply来调用父类的构造函数
   * 核心：用父类的构造函数来增强子类实例，相当于把父类的实例属性给子类（没有用到原型）
   * 特点：
     1. 创建子类时可以向父类传参
     2. 可以实现多继承（call多个父类对象）
     3. 实现了属性私有化，实例的继承的父类属性不共享
   * 缺点：
     1. 实例只是子类的实例
     2. 只继承了父类的实例属性和方法，没能继承原型属性和方法
     3. 无法实现函数复用，每个子类都有父类实例函数的副本，影响性能
3. 组合继承
   * 结合了一和二
   * 注意：
     * 将子类原型指向父类实例时，会导致子类原型的constructor指向父类构造方法；要修正回来：
     * sun.prototype.constructor=sun（constructor的定义是要指向对应构造函数的）
	* 缺点：子类原型上有两份父类实例属性，因为父类的构造函数被调用了两次
4. 寄生组合继承
* 通过借用构造函数来继承属性
* 通过原型链来继承方法
* 不必为了指定子类的原型而调用父类构造函数
* 将sub.prototype=new super()改为sub.prototype=Object.create(super.prototype)；避免构造函数被调用两次
