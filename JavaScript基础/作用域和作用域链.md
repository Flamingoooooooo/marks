# 作用域和作用域链、执行期上下文
* 作用域：变量和函数的可访问范围，控制着变量和函数的可见性与生命周期，也就是说，作用域决定了代码区块中变量和其他资源的可见性
* js采用词法作用域（静态作用域）：指在词法分析阶段就确定了，不会改变，变量的作用域在声明而不是执行时决定
* 动态作用域：根据程序的流程信息来动态确定，不关心函数在哪声明，只关心在哪调用
	一个例子：
  ```javascript
		var value = 1;
		function foo() {
			console.log(value);
		}
		function bar() {
			var value = 2;
			foo();
		}
		bar();
		// 结果是1
    ```
  调用foo时，foo里没有value，去作用域链外层找，也就是全局作用域，所以打印1
  
## 全局，局部，块级作用域：
* es6之前没有块级作用域，es6新增的let和const可以形成块级作用域
* 全局作用域：在代码任何地方都能访问的对象拥有全局作用域，全局作用域的变量是全局对象的属性,无论在什么函数中都能访问，而不需要加上全局对象，但加上可以提供搜索效率
  1. 没有用var声明的变量（函数的参数除外）都具有全局作用域，成为全局变量，所以声明局部变量必须要用var
  2. window的所有属性都有全局作用域
  3. 最外层函数体外声明的变量也具有全局作用域
* 局部作用域：优先级高于全局变量
  1. 函数体内使用var声明的变量具有局部作用域，成为局部变量
  2. 函数的参数也具有局部作用域
* 块级作用域：使用let和const声明的变量，会在for循环或if的{}中形成块级作用域

## 作用域链：JavaScript中每个函数都表示为一个函数对象，这个对象有一个仅供JS引擎使用的[[scope]]属性
* 通过语法分析和预解析，将[[scope]]属性指向函数定义时作用域中的所有对象集合，这个集合就叫作用域链，它包含了函数定义时作用域中所有可访问的数据
* 当定义函数时，其作用域链就被创建，函数所在的全局作用域的全局对象被放置到作用域链中
	
## 执行期上下文：
* 执行具体某个函数时，JS引擎在执行每个函数实例时，都会创建一个执行期上下文（EC）和激活对象（AO）
* 他们属于宿主对象，与函数实例执行的生命周期保持一致，函数执行完成他们就被销毁，闭包除外
* 执行期上下文定义了一个函数正在执行时的作用域环境，它指的是作用域，它和作用域链不同，作用域链对象[[scope]]在函数定义时是固定的，但执行期上下文会根据运行环境变化，函数每执行一次都会创建不同的EC
  * EC有自己的作用域链，创建EC时，它的作用域链将使用执行函数[[scope]]属性中包含的对象（函数定义时的作用域链对象）进行初始化
  * 这些值会按照在函数中出现的顺序复制到EC的作用域链中。

* 第一阶段：创建
调用函数，但还没有执行时：
  1. 创建变量对象VO（激活对象AO），这个对象保存了函数中所有形参实参、局部变量和this等等函数执行时内部的情况，然后将AO推送到EC作用域链的顶部
  2. 创建作用域链
	3. 设置this的值
* 第二阶段：执行
	* 顺序执行代码，改变AO中的值
* 函数执行时，每遇到一个变量都会去EC的作用域链顶部从上往下找，这就是为什么局部变量会覆盖全局变量
* 执行期上下文EC的[[scope]]指向自己的作用域链scope chain，scope chain存储着激活对象和全局对象，索引为0是自己的AO
* 索引为1是全局对象

## 闭包及其原理：外层函数被创建初始化，形成作用域链
1. 开始执行时，创造EC，AO并将AO推送到作用域链顶部，
2. 执行到闭包时，创建初始化、形成作用域链（外层函数的AO和GO（全局对象））
3. 也就是说，此时闭包作用域链和外层EC的作用域链相同，因为闭包被解析时它的作用域是外层的AO，并且由于作用域链的关系，GO也被加入闭包函数的作用域链中
4. 外层函数执行完时，闭包还没有执行，作用域链还存在着对外层AO的引用，所以外层执行完时，AO没有被消除
5. 闭包函数执行，创建EC,作用域链，AO，现在作用域链中有三个对象（自己的AO，外层AO，GO）


