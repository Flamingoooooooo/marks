# JavaScript的垃圾回收方式：
* JavaScript中主要的内存管理概念是可达性：可访问或可用的值，它一定存储在内存中
* 固有的可达值的基本集合，明显不能被释放：
	1. 当前函数的局部变量和参数
	2. 嵌套调用时，当前调用链上所有的函数的变量与参数
	3. 全局变量
	4. （另一些内部的）
* 这些值被称为roots（根）

* JavaScript引擎中，有名为垃圾回收器的东西在后台执行，他监控着所有对象的状态，并删除那些不可达的
  * 当一个或多个对象成为孤岛时，他们会被删除：
		* 没有传入引用的单个对象，是不可达的，
		* 当多个对象相互引用，但外部没有对其任意对象的引用，也就是说，与roots不相连时，这几个对象同样是不可达的

# 垃圾回收的内部基本算法
  * 执行步骤：
  1. 垃圾收集器找到所有的roots并标记他们
  2. 遍历并标记来自他们的所有引用
  3. 遍历标记的对象，并标记他们的引用，所有被遍历到的对象都会被记住，以免遍历到同一对象
  4. 循环往复，知道所有从根部可达的引用都被访问到
  5. 删除没有被标记的对象


# 优化建议：
* 分代收集：对象被分为新旧两组，许多新出现的对象完成他们的工作并死去删除，而长期存活的对象变得老旧，被检查的频次也会减少
* 增量收集：若对象太多，遍历并标记会在执行过程中带来明显延迟，因此引擎试图将垃圾收集分成几部分再逐一处理，这需要他们之间有额外的标记来追踪变化，但此时只会有许多微小的延迟二不是一个大延迟
* 闲时收集：仅在CPU空闲时尝试运行，减少对代码执行的影响
# 内存泄漏：
* 不再用到的内存没有及时释放。会影响性能甚至进程崩溃
* ES6新增weakMap和weakSet，他们对于值的引用不计入垃圾回收机制，为弱引用

