# 1.外链文件位置的相关细节：
## 外链css放在头部：
外链css在何处不影响html解析，但影响html渲染
* 放在尾部，html会先显示，但阻塞行内css渲染
* 放在头部，css下载解析和html解析同步进行，在尾部会有额外时间解析css，会先渲染出一个没有样式的页面，css加载完再渲染一个有样式的
## script为什么放在尾部
浏览器解析到script会立即下载执行，中断html的解析(这时因为dom还没加载完成，而js可能会操作dom)，把网页渲染的控制权交给js引擎，若标签引用外部脚本，就下载脚本，否则直接执行，执行完毕后把控制权交给渲染引擎，继续解析html
## defer和async的异同：
* 都仅对外部脚本有效，对内置和动态生成的不起作用
### 不同：
* async一旦加载完成就执行，defer会再dom加载完成([DOMContentLoaded]事件)时执行
* 若有多个脚本文件，async不保证执行顺序，defer会按照顺序，因此脚本间有依赖关系时，用defer，无关用async，两个一起用defer会无效，浏览器行为由async决定
### 解析过程
浏览器开始解析html->发现带有defer/async标签的script->继续解析，并行下载脚本
async->暂停html的解析，开始执行下载的脚本->执行完毕继续解析html
defer->继续解析，html->html解析完毕，执行脚本
## 带有defer/async的script标签和外链css有要求吗
js的执行依赖于css，css样式全部下载完成才执行js，所以没有要求
## DOMContentLoaded和window.onload的区别
前者在html被完全加载时触发，后者在页面全部加载完成时触发，包括依赖的样式，图片，异步js等
# 2.从url到渲染出页面
  * dns解析:
    * 先找缓存，找不到就递归向各级域名服务器查找，直到找到对应的IP

  * tcp连接：
    1. 客户端发送syn(seq=x)包
    2. 服务器收到syn包，确认syn(ack=x+1)同时自己也发送一个syn(seq=y)即syn+ack包
    3. 客户端收到syn+ack，向服务器发送ack(seq=y+1),发送完毕即完成握手,ack可以携带数据，不携带则不消耗序列号
    * 为什么不两次握手四次握手？
    * 三次握手是为了防止失效的连接请求突然又传到服务器，因而产生错误：a发送的第一个请求被阻塞，于是a再请求一次并且成功，此时第一个请求到达服务器，服务器以为a发起了新连接，于是一直等待客户端发送数据，浪费资源，增加到四次不能显著提升可靠性，没必要

  * 发送http请求(请求行，请求报头和正文)
    * 请求行：[请求方法](请求方法.md)，请求的url，http版本
    * 请求报头：客户端向服务器传递附加信息和客户端自身的信息
      * connection:keep-alive，不关闭连接
      * accept和accept-encoding设置接受的编码方式
      * cache-control
      * cookie
      * if-none-macth，用于和etag比对
    * 请求正文：正文信息，content-type

  * 服务器处理请求并返回报文([状态码](状态码.md)，响应报头，响应报文)

  * 浏览器解析和渲染页面

  * tcp断开连接
    1. 客户端发送fin以告诉服务器自己不会再发送数据(在fin之前发的数据如果被收到对应的ack响应客户端还是会重发)，此时客户端还是可以接收数据。fin=1，序列号为之前数据的最后一个字节的序号+1，然后客户端进入终止等待1状态
    2. 服务器收到fin后，发送一个ack并带上自己的seq(确认序号为收到的序号+1)，然后进入关闭等待状态，这时处于半关闭状，若服务器发送，客户端依然要接收，此时客户端进入终止等待2状态
    3. 服务器发送一个fin，告诉客户端自己的数据也发送完了，服务器进入最后确认状态
    4. 客户端收到fin后，发送一个ack，确认序号为收到的fin包的序列号+1，然后进入时间等待状态，等待2msl(最长报文段寿命)时间后进入关闭状态；而服务器收到这个ack就可以关闭了
    * 为什么还要等待2msl？
    1. 保证第四次挥手的ack能到达服务器，如果该报文丢失，服务器会认为第三次挥手客户端没收到，于是再发一次，而客户端就可以再第四次挥手并重置2msl计时器
    2. 防止失效的连接请求产生错误：客户端第四次挥手后，在2msl等待时间内保证连接时间内的所有报文都消失，这样新连接中不会出现旧的连接报文了
    * 为什么挥手是四次？
    * 连接时，服务器在第二次握手把syn和ack一起给客户端，但关闭时，仅仅表示对方不再发送了，但还能接收，而且自己也不一定发完了数据，所以自己发完可以立即关闭，把syn和ack分开了 

# 3.浏览器的渲染过程
  1. 解析html，生成dom
  2. 解析css生成cssom
  3. 解析js，操作dom和cssom
  4. dom和cssom结合形成渲染树
  5. 遍历渲染树，开始布局
  6. 浏览器将数据发送给gpu，gpu合成图层，显示
