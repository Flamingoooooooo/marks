[参考博文](https://juejin.cn/post/6844904021308735502)
# Web缓存的种类：
数据库缓存，CDN缓存，代理服务器缓存，浏览器缓存
## 强缓存：
检查强缓存时，不需要发送http请求
### 如何检查：查看相应字段
  * http1.0使用的字段是expires，表示过期时间，过期则需要向服务器请求，漏洞在于服务器和浏览器时间可能不一致（本地时间可以设置）
  * http1.1使用的字段是Cache-Control，它表示的不是具体过期时间，而是过期时长(max-age)，相对时间解决了expires的问题
  * Cache-Control的其他关键属性：
    1. public：客户端和代理服务器都可以缓存
    2. private：只有浏览器能缓存
    3. no-cache：跳过当前的强缓存，直接进入协商缓存阶段，发送http请求
    4. no-store：不缓存
    5. s-maxage：针对代理服务器的缓存时间

## 协商缓存：
强缓存失效后，浏览器在请求头中携带相应的缓存tag向服务器发送请求，服务器根据这个tag来判断是否使用缓存
### 缓存tag(两种)
  * Last-Modified：最后修改时间，浏览器第一次收到时，服务器会在响应头上加上这个字段，浏览器再次请求时，携带If-Modified-Since字段，服务器将这个字段和资源的最后修改时间对比：
    * 字段值小于资源的最后修改时间，返回新的资源
    * 返回304，通知浏览器资源没更新，使用缓存
  * ETag：服务器通过当前文件内容，给文件生成唯一标识，若内容有改变则这个值就会改变，服务器通过响应头把这个值给浏览器，浏览器接收这个值之后若再请求，就会把这个值作为If-None-Match发送给服务器，服务器用这个字段和资源的ETag比对：
    * 不相同，返回新的资源
    * 返回304
### 二者的优劣：
  * ETag在精确度上更优：若资源只是编辑，并未修改，使用Last-Modified缓存会失效；且它的感知时间是秒，若一秒改变多次，它就没有体现出修改
  * Last-Modified性能上更优：只记录时间点，ETag会根据资源内容生成hash值
  * 若两种方式都支持，服务器优先考虑ETag

## 缓存位置：

