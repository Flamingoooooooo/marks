1.原始值和引用值类型及区别：
~原始值：存储在栈中的数据段，他们的值直接存储在变量访问的位置
~引用值：存储在堆中的对象，放在变量的栈空间中值是该对象存储在堆中的地址，
	变量访问的位置是一个指针，指针指向对象的堆内存
	区别体现在：复制时：
		原始值：当把一个变量传递给另一个变量时，是把一个栈中的东西复制到另一个栈中，这两个变量互不影响
		引用值：因为存储的是对象在堆中的内存地址，所以复制的其实是对象的指针，当修改该对象的属性时，另一个变量也会跟着改变

2.JavaScript中数据类型的判断：四种方式
	typeof：空数组和null被typeof解释为object，其他类型（number，bool，string，function，object，undefined）都会被精准的解释
	instanceof：直接的字面量值判断数据类型，只有引用数据类型被准确判断，而number，bool，string不能被准确判断
		原因：instanceof时用来测试一个对象在其原型链中是否存在一个构造函数的prototype属性，意思就是判断对象是否是某一数据类型的实例，
			由于直接的简单数据类型不是实例，所以都会输出FALSE，但如果是实例化的基本数据类型，就可以准确判断
		另外：new undefined instanceof undefined（或者null）会报错，因为浏览器认为这两个不是构造器。
		为什么typeof null==object，typeof undefined==undefined？
		设计者的失误，早期准备将null的类型改为null，但是已经有大量网网站使用了，所有一直没有更改
	constructor：变量.constructor会返回它堆构造器，但不是完美的：
		如果创建的对象被修改了原型（prototype），例如Fn.prototype=new Array（），那么通过Fn创建的对象constructor都是Array而不是Fn
	Object.prototype.toString.call（）：使用object对象的原型方法toString，用call狸猫换太子，会精准的显示数据类型，就算改变对象的原型，依然会显示正确的数据类型

	问题延伸：call（）方法：调用一个对象的方法，以另一个对象替换当前对象。

3.类数组和数组的区别和转换：
	类数组定义：任何可迭代的结构，或者拥有length属性，其他索引为非负整数
		    不具有数组方法
		    元素属性名必须是数值或者可转换成数值的字符	
	常见的类数组：arguments对象、dom方法的返回结果（document.getElementsByXXX）、jQuery对象
	
	相同点：都可用下标索引访问每个元素、都有length属性
	不同点：数组对象类型为Array，遍历数组可以用for循环和for...in，而类数组对象类型为object，遍历类数组只能用for循环
	怎么区别：instanceof、constructor、object.prototype.toString.call（）、ES5的isArray方法

	类数组转换为数组：因为类数组不具有数组方法，所以经常是类数组转化为数组
	Array.prototypr.slice.call（arguments）：使用数组原型方法中的slice
	Array.from（）：可以将类数组对象和可遍历对象转为数组，es6新增的方法
	Array.of（）：将参数中所有的值作为元素形成数组，es6新增的Array构造函数
	*扩展运算符（...）：用于取出参数对象中所有的可遍历属性，拷贝到当前对象中
	遍历类数组：虽然不是数组，但有iterator接口，所以可遍历

4.数组的常用api
	isArray方法：判断是否为数组类型
	转换方法toString：转换成以逗号分隔的字符串
	模拟栈和队列的方法：push：加到最后
			 pop：弹出最后一个
			 shift：删除第一个
			 unshift：插入到第一个
	排序方法：sort（function）根据设定的规则进行排序
		 reverse方法：倒序
	操作方法：concat：连接字符串并建立副本
		 slice：切割数组，参数为起始位置和结束位置，不会影响原数组
		 splice：用于删除插入替换，参数为需要操作的位置、删除的项数、需要插入的项
	位置方法：indexof和lastindexof查找索引

5. bind、call、apply的区别：
	都是改变函数体内this的指向
	bind不同于两者的区别是：bind不会立即调用，而会返回一个新函数，称为绑定函数，绑定函数内的this指向为创建它时传入bind的第一个参数
			而传入bind的第二个及以后的参数作为原函数的参数来调用原函数
	apply和call都是为了改变某个函数运行时的上下文而存在，他们会返回函数的执行结果
	区别在于：apply的的第二个参数是一个参数数组，call的第二个及以后参数都是数组里的元素，就是说要全部列举出来
	用处：传递的参数不多时，用call方法，如果参数很多，那么整理好再调用apply方法
	          如果想生成一个新函数长期绑定某个函数给某个对象使用，就使用bind方法
	实现这三个方法：见笔记

	注意：绑定函数不可以再通过apply和call改变this指向，达不到预期效果

6.new的原理： 
	new的步骤：创建一个空对象；
						链接到原型；
						绑定this的值；
						返回新对象；
	实现new:见笔记

7.如何正确判断this指向
	简单来说，谁调用它，this就指向谁
	规则：按照以下顺序判断：
		全局环境中的this：浏览器环境下指向window，node环境指向空对象{}；无论是否在严格模式下
		new绑定的this：new绑定，且构造函数中没有返回function或object，则this指向新对象
									若构造函数返回的是funct或object，this就指向构造函数中返回的对象
	显式绑定（用bind，call，apply）：this指向绑定的对象
					特殊情况：传入的第一个参数为undefined或null。则：
							非严格模式下：this指向window（浏览器环境）或global（node环境）
							严格模式：this为传入的值（undefined或null）
	隐式绑定：函数的调用是在某个对象上触发的，即调用位置上存在上下文对象，典型为xxx.fn()
	默认绑定：不能应用其他绑定规则时的默认规则，通常是独立函数调用
						非严格模式：global/window；严格模式：undefined
	箭头函数：没有自己的this，继承外层上下文的this

8.闭包及其作用
	闭包是指有权访问另一个函数作用于中的变量的函数（能够读取其他函数内部变量的函数）
	作用：正常函数执行完后，里面的变量会被垃圾回收器处理，但闭包可以让作用域里的变量在执行完后仍保持，不会被处理
				通过这一特性，可以：
						实现公有变量（函数累加器）
						可以做缓存（存储结构）
						可以实现封装，属性私有化
	闭包的一些应用场景：见笔记
	闭包的缺陷：导致内存占用过高，因为变量都没有被释放

9.原型和原型链
	原型的概念：每个js对象创建时对会与另一个对象相关联，被关联的这个对象就叫原型，被创建的对象会从原型中继承属性
	一、prototype：每个函数都有这个属性，这个属性指向函数的原型对象；xxx.prototype就叫做原型对象
								使用这个函数创造其他的对象时，对象也继承了原型对象上的属性
	二、_proto_：每个对象都有这个属性，指向该对象的原型（p._proto_===P.prototype）
	三、constructor：每个原型都有一个constructor属性（也就是说，在prototype上），指向关联的构造函数
			也即：P.prototype.constructor===P===p.constructor;
	四、原型的原型：原型本质也是对象，也就是原型的_proto_指向原型的原型：Object.prototype

	原型链：每一个函数都有一个原型对象；
				 原型对象都包含一个指向构造函数的指针；
				 每一个实例都包含一个指向原型对象的内部指针
				 如果原型对象是另一个类型的实例；那么：
				 这个原型对象将包含一个指向另一个原型的指针；而这个原型又包含着指向另一个构造函数的指针……
				 层层递进，就构成了原型和实例的链条：原型链
	确定原型关系的方法：
		instanceof：实例和原型链中出现过的构造函数，返回true；
		isPrototypeOf：是否是参数的原型：P.prototype.isPrototypeOf(p)
		Object.getPrototypeOf(obj)返回对象的原型对象
10.prototype和_proto_的关系和区别：
	实例的_proto_指向原型对象（xxx.prototype）
	构造函数的prototype指向原型对象
	
	原型对象的constructor指向相关联的构造函数
	原型对象的好处是所有实例对象共享它的属性和方法

	当实例和原型有同名属性时，会屏蔽掉原型的属性；

	一些方法：
	判断属性是在实例中还是在原型中，使用hasOwnProperty方法，在实例中时返回true
	in操作符会遍历所有属性，无论是在实例上还是原型上
	Object.keys(obj)获取对象所有可枚举属性的名称

	如果在实例属性上没有找到想要的属性，会沿着原型链向上找；直到Object,所有的对象最终都会指向Object

11.JS继承的方式及比较
	每一个对象都有一个_proto_属性（隐式原型），每一个构造函数都有一个prototype（显式原型）
	实例的隐式原型==构造函数的显式原型
	一、原型链继承
		让子类的prototype(原型对象)等于父类的实例：sun.prototype=new dad();
		特点：1.由子类构造的实例，既是子类的也是父类的
					2.父类新增原型方法和属性子类都能访问到
		缺点：来自原型对象的引用属性时所有实例共享的，没有私有化
	二、构造函数继承
		在构造子类构造函数内部使用call或apply来调用父类的构造函数
		核心：用父类的构造函数来增强子类实例，相当于把父类的实例属性给子类（没有用到原型）
		特点：1.创建子类时可以向父类传参
					2.可以实现多继承（call多个父类对象）
					3.实现了属性私有化，实例的继承的父类属性不共享
		缺点：1.实例只是之类的实例
					2.只继承了父类的实例属性和方法，没能继承原型属性和方法
					3.无法实现函数复用，每个子类都有父类实例函数的副本，影响性能
	三、组合继承
		结合了一和二
		注意：将子类原型指向父类实例时，会导致子类原型的constructor指向父类构造方法；要修正回来：
						sun.prototype.constructor=sun（constructor的定义是要指向对应构造函数的）
		缺点：子类原型上有两份父类实例属性，因为父类的构造函数被调用了两次
	四、寄生组合继承
		通过借用构造函数来继承属性；
		通过原型链来继承方法
		不必为了指定子类的原型而调用父类构造函数
		将sub.prototype=new super()改为sub.prototype=Object.create(super.prototype)；避免构造函数被调用两次
	继承方式：见笔记

12.深拷贝和浅拷贝
	简单来说，浅拷贝只复制了地址，复制得到的对象和以前的对象指向同一块内存区域
	深拷贝把整个对象都复制下来了，内存地址不同。
	因为对象里还会嵌套对象，所以深拷贝要通过递归实现
	实现：见笔记。

13.防抖和节流
	针对响应跟不上触发的两种方式，
	若事件的回调函数较为复杂，响应跟不上触发时，页面会卡顿、假死
	当事件快速连续不断触发时，防抖只会执行一次，而节流会被定期执行

14.作用域和作用域链、执行期上下文
	~作用域：变量和函数的可访问范围，控制着变量和函数的可见性与生命周期，也就是说，
				作用域决定了代码区块中变量和其他资源的可见性
	js采用词法作用域（静态作用域）：指在词法分析阶段就确定了，不会改变，
						变量的作用域在声明而不是执行时决定
	动态作用域：根据程序的流程信息来动态确定，不关心函数在哪声明，只关心在哪调用
	一个例子：
		var value = 1;
		function foo() {
			console.log(value);
		}
		function bar() {
			var value = 2;
			foo();
		}
		bar();
		// 结果是1
		调用foo时，foo里没有value，去作用域链外层找，也就是全局作用域，所以打印1
	
	全局，局部，块级作用域：es6之前没有块级作用域，es6新增的let和const可以形成块级作用域
	全局作用域：在代码任何地方都能访问的对象拥有全局作用域，全局作用域的变量是全局对象的属性
						 无论在什么函数中都能访问，而不需要加上全局对象，但加上可以提供搜索效率
		a.没有用var声明的变量（函数的参数除外）都具有全局作用域，成为全局变量，所以声明局部变量必须要用var
		b.window的所有属性都有全局作用域
		c.最外层函数体外声明的变量也具有全局作用域
	局部作用域：优先级高于全局变量
		a.函数体内使用var声明的变量具有局部作用域，成为局部变量
		b.函数的参数也具有局部作用域
	块级作用域：使用let和const声明的变量，会在for循环或if的{}中形成块级作用域

	~作用域链：JavaScript中每个函数都表示为一个函数对象，这个对象有一个仅供JS引擎使用的[[scope]]属性
					通过语法分析和预解析，将[[scopr]]属性指向函数定义时作用域中的所有对象集合，
					这个集合就叫作用域链，它包含了函数定义时作用域中所有可访问的数据
		当定义函数时，其作用域链就被创建，函数所在的全局作用域的全局对象被放置到作用域链中
	
	~执行期上下文：执行具体某个函数时，JS引擎在执行每个函数实例时，都会创建一个执行期上下文（EC）和激活对象（AO）
					他们属于宿主对象，与函数实例执行的生命周期保持一致，函数执行完成他们就被销毁，闭包除外
		
		执行期上下文定义了一个函数正在执行时的作用域环境，它指的是作用域，它和作用域链不同，
		作用域链对象[[scope]]在函数定义时是固定的，但执行期上下文会根据运行环境变化，函数没执行一次都会创建不同的EC

		EC有自己的作用域链，创建EC时，它的作用域链将使用执行函数[[scope]]属性中包含的对象（函数定义时的作用域链对象）进行初始化
		这些值会按照在函数中出现的顺序复制到EC的作用域链中。

		第一阶段：创建
			调用函数，但还没有执行时：
				创建变量对象VO（激活对象AO），这个对象保存了函数中所有形参实参、局部变量和this等等函数执行时内部的情况，然后将AO推送到EC作用域链的顶部
				创建作用域链
				设置this的值
		第二阶段：执行
			顺序执行代码，改变AO中的值
		
		函数执行时，每遇到一个变量都会去EC的作用域链顶部从上往下找，这就是为什么局部变量会覆盖全局变量

		执行期上下文EC的[[scope]]指向自己的作用域链scope chain，scope chain存储着激活对象和全局对象，索引为0是自己的AO
				索引为1是全局对象

		闭包及其原理：外层函数被创建初始化，形成作用域链
							开始执行时，创造EC，AO并将AO推送到作用域链顶部，
							执行到闭包时，创建初始化、形成作用域链（外层函数的AO和GO（全局对象））
							也就是说，此时闭包作用域链和外层EC的作用域链相同，因为闭包被解析时它的作用域时外层的AO，并且由于作用域链的关系，GO也被加入闭包函数的作用域链中
							外层函数执行完时，闭包还没有执行，作用域链还存在着对外层AO的引用，所以外层执行完时，AO没有被消除
				闭包函数执行，创建EC,作用域链，AO，现在作用域链中有三个对象（自己的AO，外层AO，GO）


15.DOM常见的操作方式
	一、查询
		document.getElementsBy方法
	二、创建和插入
		document.createElement创建元素节点
		document.createAttribute创建属性节点
		document.createTextNode创建文本节点
		document.createComment创建注释节点
		document.createDocumentFragment创建文档片段节点
		parent.appendChild向节点的最后一个子节点后插入新节点
		parent.insertBefore（new，old）向old之前插入
		还可以复制节点参数中true表示深拷贝
	三、更新
		parentNode.replaceChild(new,old)替换节点
		element.setAttribute修改属性
		还可以设置样式
	四、删除
		parentNode.removeChild()删除子节点并返回
		element.removeAttribute删除属性
		element.removeAttributeNode删除并返回

16.Array.sort()方法与实现机制
	每个浏览器不大一样，谷歌使用快排和插入排序，火狐使用归并
	快排和插入排序：见笔记。

17.Ajax的请求过程
	即异步JavaScript和XML，XML被设计用来传输和存储数据，类似HTML
	同步和异步的区别：
			用户发送请求时，异步的当前页面还可以继续使用，在异步请求的数据响应给页面后把数据显示出来
			同步的当前页面需要等到服务器响应页面到客户端，响应完成用户才可以使用页面
	Ajax的步骤及实现：见笔记。

拓展：http的请求方式：
				常用：get，post，head
				1.1新增：options，put，connect，delete，trace

18.JavaScript的垃圾回收方式：
			JavaScript中主要的内存管理概念是可达性：可访问或可用的值，它一定存储在内存中
			固有的可达值的基本集合，明显不能被释放：
				当前函数的局部变量和参数
				嵌套调用时，当前调用链上所有的函数的变量与参数
				全局变量
				（另一些内部的）
				这些值被称为roots（根）
			JavaScript引擎中，有名为垃圾回收器的东西在后台执行，他监控着所有对象的状态，并删除那些不可达的
			当一个或多个对象成为孤岛时，他们会被删除：
			没有传入引用的单个对象，是不可达的，
			当多个对象相互引用，但外部没有对其任意对象的引用，也就是说，与roots不相连时，这几个对象同样是不可达的

			垃圾回收的内部基本算法
			执行步骤：
			垃圾收集器找到所有的roots并标记他们
			遍历并标记来自他们的所有引用
			遍历标记的对象，并标记他们的引用，所有被遍历到的对象都会被记住，以免遍历到同一对象
			循环往复，知道所有从根部可达的引用都被访问到
			删除没有被标记的对象


			优化建议：
			分代收集：对象被分为新旧两组，许多新出现的对象完成他们的工作并死去删除，
			而长期存活的对象变得老旧，被检查的频次也会减少
			增量收集：若对象太多，遍历并标记会在执行过程中带来明显延迟，因此引擎试图将垃圾收集分成几部分再逐一处理，
			这需要他们之间有额外的标记来追踪变化，但此时只会有许多微小的延迟二不是一个大延迟
			闲时收集：仅在CPU空闲时尝试运行，减少对代码执行的影响

			内存泄漏：不再用到的内存没有及时释放。会影响性能甚至进程崩溃
			ES6新增weakMap和weakSet，他们对于值得引用不计入垃圾回收机制，为弱引用

19.JavaScript中String、Array和Math方法
		见笔记。

20.addEventListener（监听）和onClick（普通）的区别
	1.addEventListener可以添加多个事件，顺序执行，onclick只能绑定一个事件，之前的会被覆盖
	2.addEventListener的第三个参数为布尔值，false为执行冒泡机制，true执行捕获
	3.addEventListener对dom元素都有效，onclick只对html元素有效
	4.解除绑定：onclick让指针指向null，addEventListener使用removeEventListener方法

捕获：从最不精确的对象document开始触发，然后到最精确
冒泡：事件按照从最特定的事件目标到最不特定的事件目标（document对象）
	例如：文档结构document > html > body > div > h5
		如果addEventLisener第三个参数为false：表示在冒泡阶段处理绑定事件
		那么会先触发h5的事件，再向上依次触发父级的事件
事件代理：例如想给每个h5添加事件，可以给父级添加事件，由于冒泡机制，会在父级触发，然后用e.target找到实际触发的元素
阻止冒泡：1.event.stopPropagation方法，只阻止事件向上冒泡
				 2.return false；还阻止了事件本身

21.new和Object.create的区别
	new中用call方法调用了构造函数，也链接了原型，因此对象继承了类的属性和原型
	Object.create没有调用构造函数，只链接了原型，因此没有继承类的属性,只继承了原型
	其他不同点：new必须以function定义，Object.create可以使function和object

22.DOM的location对象
	属性：1.href URL
			  2.host 主机（域名）
				3.port 端口号
				4.pathname 路径
				5.search 参数
				6.hash 返回片段
				7.protocol 协议
	方法：1.location.assign()跟href一样，用于重定向
				2.location.replace()替换当前页面，但不记录历史没法回退
				3.location.reload()重新加载页面，相当于按刷新，若参数为true，强制刷新
23.浏览器从输入URL岛页面渲染的整个流程
	一、获取IP地址
		通过DNS将URL解析为IP地址
			1、向浏览器缓存中查找
			2、向系统缓存查找
			3、向路由器查询DNS缓存
			4、向ISP（运营商）DNS缓存中查找
			5、向根域名服务器->顶级域名服务器中查找
		DNS预解析：根据浏览器定义的规则，提前解析可能遇见的域名，存到系统缓存，以缩短解析时间提高速度

	二、三次握手建立连接

	三、浏览器向web服务器发送http请求
		1.浏览器根据解析到的IP地址和端口号发起HTTTP请求，包括header和body
			header包括请求的方式、协议、地址、缓存cookie，body为请求的内容
		2.服务器接到请求，根据HTTP请求中的内容来决定如何获取相应的HTML文件
		3.服务器将得到的HTML文件发送给浏览器

		客户端请求静态资源和动态资源：
			1.静态：服务器会根据URL地址到服务器的对应路径下找文件，然后返回一个HTTP响应，包括状态行、响应头、和响应正文
			2.动态：服务器调用CGI/VM执行程序，得到应用程序的返回结果后，再把结果响应给客户端
				CGI/VM：是web服务器和web应用程序交流时的规范

	四、浏览器渲染

	五、四次挥手断开连接

24.跨域、同源策略及跨域实现方式和原理
	跨域：浏览器出于安全考虑，有同源策略（SOP）,就是说，协议、域名、端口其中之一有不同就是跨域，Ajax会请求失败
			它主要用来防止CSRF（跨域请求伪造），简单来说，CSRF时利用用户登录态发起恶意请求
			若没有同源策略，网站可以被任意其他来源的AJax访问到内容，如果现在我在这个网站出于登录态，对方可以
			通过Ajax获得我的信息，但它并不能完全阻止CSRF
	注意点：虽然请求跨域，但是请求实际上还是发出去了，只是浏览器拦截了响应
					表单可以发起跨域请求，因为表单不会获取新的内容，跨域是为了阻止用户读取另一个域名下的内容，
					Ajax可以获取响应，浏览器认为这不安全，于是拦截了响应
	跨域的解决方式：1.通过jsonp跨域
								 2.document.domain+iframe
								 3.location.hash+iframe
								 4.window.name+iframe
								 5.postMassage跨域
								 6.CORS跨域资源共享
								 7.nginx反向代理
								 8.nodejs中间件代理
								 9.websocket协议跨域
	JSONP和CORS的实现：见笔记
	
25.浏览器的回流和重绘
	如果直接对DOM进行操作，修改DOM节点的位置大小等几何属性，会导致DOM树的变化，浏览器会重新构建DOM树，叫做回流
	如果只是修改了颜色，DOM结构没有发生改变，页面布局也没有发生改变，虽然不会重新构建DOM树，但会重新渲染页面，叫做重绘
	回流一定会重绘，重绘不一定回流
	从浏览器渲染页面的流程来说，回流需要从布局开始，重绘只用从渲染开始

26.JavaScript中的arguments
	类数组对象
	属性名按照参数传入的顺序，"0""1""2"
	arguments的_proto_指向object，说明它是类数组对象，而不是数组
	arguments里还有一个callee的属性，表示当前函数的引用，会把当前函数这段代码返回
	一些用法：实现重载，js里没有重载，可以通过判断arguments的length来实现重载
					 用arguments.callee实现递归，比如想递归匿名函数，在严格模式，这个方法被禁止（ES4）

27.EventLoop事件循环
28.宏任务与微任务
29.BOM属性对象方法

30.函数柯里化及其通用封装：见笔记

31.JS的map和reduce方法，见19
	map的参数是一个函数，返回原数组所有值经过这个函数处理后生成的新数组
	reduce的参数也是函数，返回根据这个函数的合并方法将原数组所有值合并得到的值

32.
三等号比较类型和值，==只比较值
三等号在比较obj类型时，会比较指针，其他时候比较类型再比较值
==类型相同比较值，不相同先转换，再比较
转换规则：string，bool，number优先转换为number比较，null和undefined相等，Nan和所有值不相等，包括自己

33.setTimeOut用作倒计时会什么会产生误差
定时器属于宏任务，如果当前执行栈所花费的事件大于定时器时间，由于定时器的回调在宏任务里，来不及去调用，所以产生误差



