1. 、、rem适配原理
2. 不定宽高水平垂直居中（重复4）绝对定位+translate，grid，flex，table-cell
3. 、、url到页面的呈现（重复4）查缓存-dns解析-三次握手-http请求-四次挥手-解析-布局-渲染-显示页面
4. 、、js阻塞解析怎么办（重复4）
5. 、、线程与进程（重复3）
6. 、、死锁和解决方式，nodejs有这个问题吗（重复4）
7. 、、跨域和解决方式（重复2）
8. 、、http缓存（强弱），cdn原理和更新（提交对应的url）
9. 、、const Fn=()=>{console.log(this)};Fn()报错，箭头函数不能作为构造函数（重复3）
10. 、、css级联规则：red,谁写在css后面就用谁（重复4）
    ```html
    <style>
      .blue{color:blue}
      .green{color:green}
      .red{color:red}
    </style>
    <div class="green red blue">123</div>
    ```
11. 设计模式的原则
12. 、、嵌套数组翻转（重复4）
<!-- 这两个react问题
13. flux数据流
14. class component连调两次setState，视图更新几次：1次 -->
15. 、、一个关于提升的编程题（重复3）
16. 、、跨域传cookie，cors传递cookie：withCredentials：true（重复3），用request header和token与用cookie有啥不同，例如post
17. 、、cookie的特性
18. 、、js发布订阅
19. 、、display的属性和默认值  block，inline，inline-block，none，flex，grid，根据自己是啥元素决定是啥默认值
20. 、、http常见状态码
21. 、、tcp断开谁发起的，tcp断开和页面渲染的顺序（重复2）
22. 、、直接使用ip还会dns查找吗，为啥不直接用ip，不会dns查找，因为ip不好记，而且大型网站通常会有很多个ip，我们访问的只是某一台，只有一台负担太大了
  ******************************************
23. 、、柯里化
24. 、、event loop（过）
25. 、、合并有序数组
26. 、、基本数据类型（和区别）
27. 、、区别对象和数组
28. 、、跨域（过）（重复2）
29. 、、http状态码
30. 、、最小栈
31. 、、看test.html
32. 前后端路由，histroy和hash
33. 、、原型链（2分）错了一个，给某属性赋值undefind会让该值为undefind，不会找原型链
34. 、、let const var 作用域和作用域链
35. 、、promise和async await
36. 、、浏览器渲染流程，重绘和回流
37. 、、css的定位属性
38. 、、display：none和visibility：hidden区别
39. 、、import原理和commonjs的require区别
40. 、、优化网页加载速度
41. 、、cookie和session
42. 、、http缓存
43. 、、计算属性和监听属性
44. 、、vue2和3的区别
45. 、、tcp和udp
46. promiseall
47. 创建长度为n的空数组，每个数组是空对象


1. 、、js类型和检测
2. 、、new和原型链
3. 、、this在运行时确认，箭头函数除外
4. 、、异步
5. 、、事件传播和事件委托
6. 、、跨域
7. 、、伪类和伪元素first-child,last-child,visited,表单类伪类:disabled,read-only||after,before,fisrt-line(letter),
8. 、、死锁
9. 、、三握四挥
10. 、、线程和进程（浏览器）
11. 、、网络分层（七层模型），tcp，arp
12. 、、ssl加密，对称和非对称混合的好处
13. 、、ES6：promise，解构赋值，箭头函数
14. 、、判断对象是否是数组
15. 、、进程调度策略：先来先服务，短作业优先，高响应比，时间片轮转，最高优先级调度算法，多级反馈队列
16. 、、浏览器缓存机制
17. vue router hash和history的区别
18. 、、http2和3
19. 、、移动端适配
20. 、、常见设计模式
21. 、、http状态码
22. 、、js能准确表示的最大整数 2^53-1,指数位11位，符号位1位，总共64位，只有52个空，超过之后会忽略53之后的位，2^53和比他大的数都相等
23. webpack
25. 、、http2和1.1的区别

算法题：
1. 、、括号生成
2. 、、最大回文子串
3. 、、防抖
4. 、、三栏布局
5. 、、三角形（等腰）
6. 、、圣杯，双飞翼
7. 、、第三大的数，一次遍历，保存三个变量
8. 、、两列布局
9.  、、深拷贝
10. 、、快排
11. 、、发布订阅和观察者
*******************************
# 三面
1. 、、webpack实现原理
2. 、、tree shaking，读文件的import语句形成依赖图，去掉没被引用的，最后打包
3. 、、前端技术体系
4. 、、项目上的优化：节流
5. 、、为什么三次握手
6. 、、http缓存，为什么有这样的缓存机制
7. 、、进程和线程
8. 、、事件循环
9. 、、渲染时哪些进程分给gpu，哪些给cpu:render渲染交给gpu，其他交给cpu
10. 未来的规划，全栈或者ui
11. 、、前端包管理的工具，npm，pnpm，yarn
12. 、、性能检测和优化：指标：首屏加载时间，首次可交互时间，输入延迟等
                  检测：有网站可以检测，F12查看各种指标
                  优化：懒加载，ssr，cdn，减少请求（拦截器，缓存），http2，事件委托，减少重绘重排，降低css选择器的复杂性
13. 、、登录的实现，token+post request body，后端验证token
14. 、、什么是cookie
15. 、、https协议
16. 、、loader和plugin的差异：
          webpack本身只能打包commonjs规范的文件，因此css图片这些没法打包，loader专注于转化文件完成压缩打包翻译，
          而plugin是插件，不局限于打包，可以增强webpack的各种功能，例如提取第三方库和公共模块，多文件合并，避免首屏加载的bundle
          另外，loader在文件编译时，也就是打包之前运行，plugin整个编译周期都在运行
17. 、、webpack编译优化的方式
18. 、、提升代码的可维护性 eslint，注释，规范命名规则，逻辑复用
19. 避免过度设计
20. 、、提升项目的编译速度：babel-loader的cacheDiretory缓存，cache-loader把处理结果缓存，还有一些别的插件 hard source webpack plugin，好像还有bundle可以有js的懒加载
21. 、、模块化的标准 commonjs es6
22. 、、闭包，好处坏处
23. 、、捕获冒泡
24. 、、事件代理
25. 、、bom 浏览器对象模型，location对象，window对象，navigater对象，screen对象，history对象


手写部分：
1. 、、千分位，保留两位用toFixed（2）
2. promisfiy
3. ajax
4. 、、股票的最大利润
5. 、、柯里化
6. 继承
7. 有序数组合并，倒序，去重
8. promise
9. 、、防抖和节流
10. 、、最长回文子串
11. 异步任务控制器
12. 并发请求限制
13. 、、数组结构转tree（2）

************
1. 、、原型链
2. 、、事件循环
3. 、、js表示的最大整数 2^53-1
4. 、、快排和使用场景，利用filter五行解决，数据量大的场景
5. 、、设计模式：发布订阅，观察者，策略，工厂，单例，装饰器……
6. 、、http状态码
7. 、、stickty
8. 、、xss避免
9.  、、现在在学什么，怎么学 vue，打算学ts，然后node这些，vue在看尚硅谷视频，做毕设打算用ts和node，到时候简单用用，希望有些了解，之后系统学习
10. 、、避免ajax重复请求，比如重复的url，拦截器，请求队列
11. 、、防抖节流
12. 、、post的数据格式，urlencoded，form-data，json
13. v-bind
14. .sync怎么实现  $emit(update)
15. webpack模块联邦
16. 、、display属性
17. 、、flex和flex1


2 稀烂
2.5 差点及格
3 符合预期
3+  
4

js 3以上
es6  3
css  3
vue  2+  3-
计算机网络  3
      tcp 
  1. tcp udp区别，可靠性，面向连接，首部字段，连接数，tcp面向字节流，udp面向报文
  2. tcp三握四挥，流程syn，ack，序列号是什么，两次握手行不行，为什么两次不行，为什么握手三次，挥手是四次，为什么要等待2msl
      1. http,1.0 1.1 2 3之间的区别
      2. https，ssl加密 https=http+ssl，ssl是非对称加密，
        * 公钥（加密），私钥（解密），
        浏览器生成一个会话秘钥（一个随机的字符串），用客户端给的公钥去加密会话秘钥，然后发送给服务器，服务器用私钥解密，得到会话秘钥，然后两边都有了会话秘钥，就都用会话秘钥加密文件传输。
        * 比如说现在有中间人，服务器传输公钥的时候，被中间人拿到，中间人把自己的公钥发给浏览器，
        浏览器用中间人的公钥加密了会话秘钥发给了中间人，中间人就拿到了会话秘钥，中间人再发回给客户端，这个时候三者都有会话秘钥，中间人可以读取和篡改传输文件的信息。
        * ca证书：公钥在证书里边，给每一个服务器给证书，浏览器会去ca找这个证书，浏览器知道自己要访问的是谁，这时中间人返回自己的公钥就会被发现
        * 非对称加密加密的是什么？会话秘钥
        * 两边都有了会话秘钥之后，还是非对称加密吗？不是
        * https是非对称加密和对称加密的结合
      支持tcp的协议，支持udp，http3
      arp
      dns解析，是一个递归和迭代的过程，dns实际上相当于一个数据库，里边存储着url和ip地址的对应关系
      http请求方法，get post options head delete put
      * 请求状态码
      * http缓存
        缓存有啥用呢？减少http请求，增强用户体验
        缓存存在哪？浏览器，客户端
        如果我想要一个资源，我先看缓存，有，就用，没有就发送请求。
        但服务端的资源可能更新，所以缓存不一定好使。
        强缓存：
        * 第一次请求时，服务端返回资源，在响应头中，说：缓存在今晚12点过期（expires，http1.0用），浏览器和服务器时间不一致，就会导致问题
        * 第一次请求时，服务端返回资源，在响应头中，说：缓存过三小时过期（max-age，http1.1用），浏览器和服务器时间不一致，就会导致问题
        弱缓存（协商缓存）：
        * 第一次请求时，服务端返回资源，在响应头中，说：资源被修改的时间是九点（last-modified），浏览器下次请求，就会把记住的被修改时间（if-modified-since）发给服务器，服务器进行比对，如果文件没改，返回304，如果文件改了，返回200+改过的文件
        * last-modified记录的是资源的最后修改时间，单位为秒，如果只是编辑，并没有修改，last-modified也会被改
        * etag（if-none-macth）根据文件内容生成hash值，文件被改hash值就被改，避免了last-modified的问题，缺陷：生成hash值浪费资源  
      * 浏览器缓存：localStorage，sessionStorage，cookie，indexDB
      * osi七层模型，每一层的作用，能说点就行
操作系统  2.5
      进程线程
      死锁，nodejs死锁 银行家算法，资源顺序分配
      线程调度，
      并行并发
webpack 2
  怎么工作的，怎么个原理
  你用过什么

设计模式 1
  单例，工厂
  观察者模式
  发布订阅模式
git 1
  版本回滚

浏览器
  同源策略，跨域
  dom 
  bom
  window

前端网络安全

简历和自我介绍 


1.最小栈
2.千分位
3.合并有序数组

1.斐波那契数列，递归和动态规划
2.青蛙跳台阶
3.礼物的最大价值
4.股票的最大利润


