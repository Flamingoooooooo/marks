[参考博文](https://juejin.cn/post/6844904021308735502)
# Web缓存的种类：
数据库缓存，CDN缓存，代理服务器缓存，浏览器缓存
## 强缓存：
检查强缓存时，不需要发送http请求
### 如何检查：查看相应字段
  * http1.0使用的字段是expires，表示过期时间，过期则需要向服务器请求，漏洞在于服务器和浏览器时间可能不一致（本地时间可以设置）
  * http1.1使用的字段是Cache-Control，它表示的不是具体过期时间，而是过期时长(max-age)，相对时间解决了expires的问题
  * Cache-Control的其他关键属性：
    1. public：客户端和代理服务器都可以缓存
    2. private：只有浏览器能缓存
    3. no-cache：跳过当前的强缓存，直接进入协商缓存阶段，发送http请求
    4. no-store：不缓存
    5. s-maxage：针对代理服务器的缓存时间

## 协商缓存：
强缓存失效后，浏览器在请求头中携带相应的缓存tag向服务器发送请求，服务器根据这个tag来判断是否使用缓存
### 缓存tag(两种)
  * Last-Modified：最后修改时间，浏览器第一次收到时，服务器会在响应头上加上这个字段，浏览器再次请求时，携带If-Modified-Since字段，服务器将这个字段和资源的最后修改时间对比：
    * 字段值小于资源的最后修改时间，返回新的资源
    * 返回304，通知浏览器资源没更新，使用缓存
  * ETag：服务器通过当前文件内容，给文件生成唯一标识，若内容有改变则这个值就会改变，服务器通过响应头把这个值给浏览器，浏览器接收这个值之后若再请求，就会把这个值作为If-None-Match发送给服务器，服务器用这个字段和资源的ETag比对：
    * 不相同，返回新的资源和200
    * 返回304
### 二者的优劣：
  * ETag在精确度上更优：若资源只是编辑，并未修改，使用Last-Modified缓存会失效；且它的感知时间是秒，若一秒改变多次，它就没有体现出修改
  * Last-Modified性能上更优：只记录时间点，ETag会根据资源内容生成hash值
  * 若两种方式都支持，服务器优先考虑ETag

## 缓存位置(按优先级高低)：
1. Service Worker：借助web worker的思路，让js运行在主线程之外，脱离浏览器窗体，因此不能访问dom，但他还是有很多功能，如离线缓存，消息推送和网络代理，其中离线缓存就是Service Worker Cache
2. Memory Cache：内存缓存，效率快，缺点在于容量和存储时长
3. Disk Cache：硬盘缓存，优点在于容量和存储时长，
  * 比较大的js和css文件被丢进磁盘，反之丢进内存，内存使用率较高时优先进入磁盘
4. Push Cache：浏览器缓存的最后防线，http2中的内容

# 浏览器的本地存储
* cookie
* webStorage
  * localStorage
  * sessionStorage
* IndexedDB
1. cookie：本质是浏览器内存中的一个文本文件 ，以键值对方式存储，向同一个域名发送请求都会携带它，服务器解析它就能拿到客户端的状态
   * 缺陷：
   * 容量缺陷，体积只有4kb
   * 性能：cookie紧跟域名，不管域名下的某个地址是否需要，cookie都会被携带，造成浪费
   * 安全：纯文本的方式在浏览器和服务器间传递，容易被截获和篡改，在httponly为false的情况下，能直接被js脚本读取
2. localStorage
   * 和cookie一样针对一个域名
   * 区别：
   * 容量为5m
   * 只存在于客户端，默认不参与与服务端的通信，避免了cookie的性能和安全问题
   * 接口封装，通过localStorage暴露在全局，有setItem和GetItem方法操作
3. sessionStorage
   * 和localStorage的区别：
   * sessionStorage是会话级别的存储，不是持久化存储，会话结束就消失，localStorage不手动清除就一直在
4. IndexedDB
   * 运行在浏览器上的非关系型数据库：支持事务，存储二进制数据
   * 键值对存储(对象仓库)
   * 异步操作，对数据库的读写异步进行了支持
   * 同源策略
